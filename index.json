[{"categories":["web"],"contents":"超文本傳輸協定(HTTP) 超文本傳輸協定（英語：HyperText Transfer Protocol，縮寫：HTTP）是一種用於分佈式、協作式和超媒體訊息系統的應用層協定。HTTP是全球資訊網的數據通信的基礎。\n設計HTTP最初的目的是為了提供一種發布和接收HTML頁面的方法。透過HTTP或者HTTPS協定請求的資源由統一資源識別碼（Uniform Resource Identifiers，URI）來標識。\n主要是架構於 TCP/IP 之上的 應用層，為 無狀態 的 請求-回應 通訊協定。\nHTTP/1.0  用戶端以ASCII字元為主，可發送多行命令(含標頭) 伺服器回應也以ASCII字元為主，回應內容區分  狀態列 回應標題 回應內文主體   每完成一次 Request/Response 交握就會關閉TCP/IP連線。  HTTP/1.0 400 Bad Request Content-Type: text/html;charset=UTF-8 Referrer-Policy: no-referrer Content-Length: 1555 Date: Mon, 02 May 2019 03:03:08 GMT\nHTTP/1.1 傳輸協議效能改進\n 持續連線狀態 (persistent connection)   1.0版時完成一次request就會斷線，1.1版後透過持續連線如讀取一個網頁圖片與頁面文字內容而不需重新連線。  切塊編碼傳輸 (chunked encoding transfer)    分塊傳輸編碼（Chunked transfer encoding）是超文本傳輸協議（HTTP）中的一種數據傳輸機制，允許HTTP由網頁伺服器發送給客戶端應用（通常是網頁瀏覽器）的數據可以分成多個部分。分塊傳輸編碼只在HTTP協議1.1版本（HTTP/1.1）中提供。\n  HTTP 1.1引入分塊傳輸編碼提供了以下幾點好處：\n HTTP分塊傳輸編碼允許服務器為動態生成的內容維持HTTP持久鏈接。通常，持久鏈接需要服務器在開始發送消息體前發送Content-Length消息頭字段，但是對於動態生成的內容來說，在內容創建完之前是不可知的。 分塊傳輸編碼允許服務器在最後發送消息頭字段。對於那些頭字段值在內容被生成之前無法知道的情形非常重要，例如消息的內容要使用散列進行簽名，散列的結果通過HTTP消息頭字段進行傳輸。沒有分塊傳輸編碼時，服務器必須緩衝內容直到完成後計算頭字段的值並在發送內容前發送這些頭字段的值。 HTTP服務器有時使用壓縮 （gzip或deflate）以縮短傳輸花費的時間。分塊傳輸編碼可以用來分隔壓縮對象的多個部分。在這種情況下，塊不是分別壓縮的，而是整個負載進行壓縮，壓縮的輸出使用本文描述的方案進行分塊傳輸。在壓縮的情形中，分塊編碼有利於一邊進行壓縮一邊發送數據，而不是先完成壓縮過程以得知壓縮後數據的大小。    位元範圍請求 (HTTP range requests) 提供向server要抓取資料多少位元，ex:檔案下載用途。  curl -I http://i.imgur.com/z4d4kWk.jpg  HTTP/1.1 200 OK ... Accept-Ranges: bytes Content-Length: 146515 curl http://i.imgur.com/z4d4kWk.jpg -i -H \u0026#34;Range: bytes=0-1023\u0026#34;  Request GET /z4d4kWk.jpg HTTP/1.1 Host: i.imgur.com Range: bytes=0-1023  Response HTTP/1.1 206 Partial Content Content-Range: bytes 0-1023/146515 Content-Length: 1024 ... (binary content) 額外快取機制 (cache control)   瀏覽器提供cache機制當網頁重新讀取時不用重新進行資料載入。  public 此回應可以被任何快取軟體儲存起來，即使它本身通常是不可快取的。\nprivate 此回應只可以被瀏覽器儲存起來，即使它本身通常是不可快取的。如果你真的不要任何快取軟體儲存你的回應，可以使用 no-store 。這個指令不是用來防止快取軟體儲存回應的。\nno-cache 此回應可以被任何快取軟體儲存起來，即使它本身通常是不可快取的。不過，在使用儲存起來的 HTTP 回應之前，必須必須向後端伺服器做驗證，因此你不能拿 no-cache 跟 immutable 一起使用。如果你真的不要任何快取軟體儲存你的回應，可以使用 no-store 。這個指令不是用來防止快取軟體儲存回應的。\nno-store 此回應不能被任何快取軟體儲存起來。當然它無法防止 先前儲存起來 的回應被回傳。客戶端可以用 max-age=0 來清除快取，並強制向後端伺服器做驗證。（其他指令跟 no-store 一起使用都無效）\n  請求用指令  Cache-Control: max-age=\u0026lt;秒數\u0026gt;  Cache-Control: max-stale[=\u0026lt;秒數\u0026gt;]  Cache-Control: min-fresh=\u0026lt;秒數\u0026gt;  Cache-Control: no-cache  Cache-Control: no-store  Cache-Control: no-transform  Cache-Control: only-if-cached   回應用指令  Cache-Control: must-revalidate  Cache-Control: no-cache  Cache-Control: no-store  Cache-Control: no-transform  Cache-Control: public  Cache-Control: private  Cache-Control: proxy-revalidate  Cache-Control: max-age=\u0026lt;秒數\u0026gt;  Cache-Control: s-maxage=\u0026lt;秒數\u0026gt;  請求管線作業 (request pipelining)   是將多個HTTP請求（request）整批送出的技術，而在傳送過程中不需先等待服務器的回應。   參考資訊 超文本傳輸協定(wiki)\nrfc2616\nmdn web docs\n","permalink":"https://jackson99011.github.io/blog/http/","tags":["frontend"],"title":"HTTP"},{"categories":["design pattern"],"contents":"原則(Principle)  所謂原則 就是一種概念或價值用來引導你來產生適切的行為與價值評量的方法。 依循原則比例越高代表程式碼品質越好。  OOP物件導向設計的Solid設計原則  單一責任原則 (SRP，Single Responsibility Principle) 開放/封閉原則 (OCP，Open Close Principle) Liskov替換 (LSP，Liskov Substitution Principle) 介面隔離原則 (ISP，Interface Segregation Principle) 依賴反轉原則 (DSP，Dependency Inversion Principle)  內聚力(Cohesion) 在一個類別完成一件工作的度量指標\n高內聚力  在類別內可以獨立運作且更容易重複利用。  低內聚力  在類別內可完成多項工作，造成難以回復、測試、重用、理解。 Ex:在一個方法中存在2000行程式，造成程式難以維護。  最佳目標 設計高內聚的程式碼，即在類別中完成多項功能的方法拆分成不同的類別。\n耦合力(Coupling) 類別與類別間互相依賴的關係度，即改變了A模組B模組異動的幅度，通常越小越好，所以目標越接近低耦合的程式越好。\n結論 高內聚低耦合為程式設計目標。\nSRP的基本精神  一個類別應該只對唯一的一個腳色負責，不是一個函式只做一件事，而是當類別負擔太多責任時，需進行適當的切割，方便日後管理與維護。 主要目標就是提高內聚力。  SRP注意事項  不用急於在第一時間就專注於分離責任 尚未出現的需求 (未來的需求) 不需要預先分離責任 當需求變更的時候，再進行類別分割即可。  OCP的基本精神  軟體應該是對於擴充開放的，但是對於修改封閉的 類別開放  透過繼承去實現 擴充方法去實現   類別封閉  有其他人在使用此類別 可有效避免未知問題產生。    OCP實作方式 採用分離與相依技巧，相依於抽象類別\npublic interface ProductService {  Integer countProduct(ProductQueryParams productQueryParams); }  @Component public class ProductServiceImpl implements ProductService {  @Autowired  private ProductDao productDao;   @Override  public Integer countProduct(ProductQueryParams productQueryParams) {  return productDao.countProduct(productQueryParams);  } } OCP使用時機  類別已被清楚定義，處於一個強調穩定狀態。 需要擴充現有的類別，加入新需求的屬性或方法 修改現在程式，會破壞現有系統運作。  LSP定義  當實作繼承時，必須確保型別轉換後還能得到正確的結果。 每個衍生類別都能正確替換為基底類別，且程式執行不會有異常產生。 正確實做繼承與多型  public class LSP {  public static void main(String[] args) {  List\u0026lt;Product\u0026gt; products = new LinkedList\u0026lt;\u0026gt;();   products.add(new Product());  products.add(new Fish());  products.add(new Goldfish());  products.add(new NotForSale());   for (Product currentProduct : products)  {  currentProduct.count();  currentProduct.price();  }  } }  class Product {  public void price() {  System.out.println(\u0026#34;price = 0\u0026#34;);  }   public void count()  {  System.out.println(\u0026#34;count = 0\u0026#34;);  } }  class Fish extends Product {  @Override  public void price()  {  System.out.println(\u0026#34;Fish price = 10\u0026#34;);  }  @Override  public void count()  {  System.out.println(\u0026#34;Fish count = 10\u0026#34;);  } }  class Goldfish extends Fish {  @Override  public void price()  {  System.out.println(\u0026#34;Goldfish price = 50\u0026#34;);  }  @Override  public void count()  {  System.out.println(\u0026#34;Goldfish count = 50\u0026#34;);  } }  class NotForSale extends Product {  //無價(無須此項次)  @Override  public void price()  {  }  @Override  public void count()  {  System.out.println(\u0026#34;NotForSale count = 1\u0026#34;);  } } inteface replace interface Price {  void price(); }  interface Count {  void count(); } class Product implements Count,Price {  @Override  public void price()  {  System.out.println(\u0026#34;Product price = 0\u0026#34;);  }  @Override  public void count()  {  System.out.println(\u0026#34;Product count = 10\u0026#34;);  } } class NotForSale implements Count {  @Override  public void count()  {  System.out.println(\u0026#34;NotForSale count = 1\u0026#34;);  } } LSP實作方法  採用繼承方式開發，確保繼承實作方法 基底類別使用介面方式執行  ","permalink":"https://jackson99011.github.io/blog/designobject-2/","tags":["Object-oriented"],"title":"設計原則-1"},{"categories":["design pattern"],"contents":"OOP的四個特性 抽象(Abstration)  抽象可以想像成一種概念，並不存在於世界上。 將真實世界的需求轉換為物件導向的類別，類別包含屬性和方法。  abstract class Printer{  int type;  String name;  void printf(){  System.out.println(\u0026#34;write...\u0026#34;);  } } 封裝(Encapsulation)  隱藏或保護內部實作細節，不讓人直接存取使用，僅提供公開方法供存取。  private 私有 private是資訊隱藏會普遍使用的修飾子，開放全限最低，只有自己類別的成員能夠存取。\npublic 公開 與private相反，public是任何人都可以調用，通常用來表示這個方法可以供一般人呼叫。\npublic class User {   private String userId;   private String userName;   private String password;   public void setUserId(String userId) {  this.userId = userId;  }   public void setUserName(String userName) {  this.userName = userName;  }   public String getPassword() {  return password;  }   public void setPassword(String password) {  this.password = password;  } } 繼承(Inheritance) 建立新類別有階層關係並可重複利用，子類別會擁有父類別的所有屬性、方法，再加上自己定義的屬性及方法，所以可以說子類別是父類別的延伸(extend)。\npublic class 子類別 extends 父類別{  // code } 多型(Polymorphism)  相同介面下可以用不同型別來實現 多型分好幾種不同的類型  基底類別可以定義和實作虛擬屬性和方法。 衍生類別可以覆寫這些虛擬的屬性或方法。   多載(Overloading)  相同函式卻有不同的輸入引數    ","permalink":"https://jackson99011.github.io/blog/designobject-1/","tags":["Object-oriented"],"title":"物件導向核心"},{"categories":["職涯發展"],"contents":"如何才有資格稱為資深工程師? 外部參考引用(如何才有資格稱為資深工程師)\n技術能力層面 對工具技術有深入的掌握度 這個特點大概是一般人用來評斷資深工程師能力最明顯的表象特徵，也就是是否將常用的工具能練得很熟或是對語言理解得夠深，同時也將技術內化到自己平常的開發習慣裡，達到信手捻來的境界。這樣的資深工程師在開發上能有全面性的考量，同時也能幫助團隊更有效率地達成目標。\n反指標： 有時這個能力會以個人開發的效率來評估，使得有人常常誤認為只要能很快完成功能就有資格當資深工程師，但他們卻忽略掉其他更值得注意的能力，結果為團隊帶來災難。\n能寫出可理解可維護的程式碼 這個特點的特徵就是平時就會撰寫測試、並對自己的程式碼做重構；對於自己的程式碼風格、變數或方法名稱等都非常要求，也絕對不會特意去走難懂的捷徑。這樣的資深工程師是非常自律的，所以被他 code review 時可能會有點痛苦，但絕對會學到很多。通常到這個階段的工程師，都是心靈上已經受過不少傷害，也對自己發過誓不再讓自己的程式碼傷害他人。\n反指標： 有些工程師會過度強調工具或標準帶來的規範，反而讓整個團隊疲於應付這些規則，失去了開發上的敏捷與效率。\n選擇技術的能力 雖然實務經驗豐富而能夠精準判斷是資深工程師的優勢之一，然而在面臨專案要使用的技術選項時，資深工程師不會把自己的喜好的技術強加在團隊上，而是跟團隊一起討論與研究，並在多方考量後去挑選出最適合這個專案以及這個團隊的技術。\n反指標： 有些時候老鳥會認為他所習慣的舊技術可以解決一切問題，即便這種技術維護起來不那麼容易。當專案使用新技術遇到瓶頸時，他不會伸手幫忙，反而會在旁幸災樂禍。\n軟體架構分析與設計能力 這個階段的能力靠得是非常多的實戰與專案經驗，加上對理論的融會貫通才能得到。一個優秀的資深工程師可以針對需求做出完整的分析，並從上而下、由粗到細地規劃出良好的軟體架構設計，也能在程式效率與可理解性之間取得平衡。他們對於每個技術的生態系都有一定程度的瞭解，幫助自己的規劃時能夠更快找到工具，也能避開嚴重的缺陷。\n反指標： 有些工程師可以將書中理論背得滾瓜爛熟，但在實際設計時卻沒有看清現實而規劃出不甚合理的架構，這是多數理論派工程師的通病。\n圖像解說能力 能夠在解釋一個技術時，用簡單清楚的圖形來解釋原理，這點是資深工程師必備的能力。通常如果能用手繪圖形的方式來說明，表示對該技術的原理已經有足夠的瞭解。從畫出來的圖也能看出工程師對於知識的組織能力，好的圖像組識要能讓其他人一眼就能理解知識的全貌，這全仰賴工程師對該知識的理解。\n反指標： 有些工程師會只畫個方塊或圓形，然後就開始講解；而在講解過程中，動筆的次數也不多；也有些工程師只是把記憶裡的圖形畫出來，但卻說不出所以然。這些都是圖像解說能力不夠的現象。\n文件編寫能力 多數的軟體工程師都討厭別人不寫文件，但討厭自己寫文件。其實寫開發文件並不是浪費時間的事情，而是可以減少其他開發者跑來打擾自己的機會。只是很多數人對於自己的文筆沒有太大的自信，把它當成不寫文件的藉口。資深工程師通常會在文件中交代這個專案的背景、架構以及如何安裝、維護等資訊，事實上他們會以未來的自己要重新接手這個專案的心情來寫，這樣就不會認為寫文件是痛苦的事了。\n反指標： 有些工程師會用自動產生器生出制式化文件後就交差了事，認為這樣就盡了編寫文件的責任。但通常這些文件僅僅包含函式和參數的名稱，沒有任何它為何存在的說明，參考的價值並不大。有時文件不見得要另外寫，註解裡也是說明為什麼的好地方。\n能綜觀全局的能力 在討論一個新功能，或是修改一個舊功能時，能不能考慮到所有會被影響的層面，進而判斷如何處理。另外這也考驗著資深工程師的記憶能力，因為通常這不是已經踩過無數類似的雷，就是對系統已經瞭若指掌了。資深工程師會站在俯瞰的角度來觀看整個專案全貌，並權宜各種技術面的優缺點後，提出可行的方案讓決策者參考，也讓其他執行的工程師在實作時能夠有依偱的方向。\n反指標： 有些工程師會過度憂慮未來的情況，而提出一些其實沒有明顯必要的因應措施；有時這些人是為了讓自己能佔有一席之地，所以用一些沒有根據的論點來讓自己顯得很資深。\n嘗試導入對團隊更好的流程 資深工程師會從木桶定律體認到自己的效率不等於團隊的效率，所以會試著導入良好的開發流程，或是自動化佈署等讓團隊能更有效率的技術。在這期間，他會透過 code review 或是教育訓練的方式來協助伙伴們往好的方向前進，讓他們感受到好的開發流程所帶來的好處。\n反指標： 有些工程師很喜歡新技術，而沒有考慮到團隊的接受度就貿然導入；這種狀況很容易造成浪費過多人力在解決一些新技術所帶來的新麻煩，進而影響整個團隊的士氣。\n心理素質層面 真正能完成一件事的自信 這個特點並不是指自傲，而在技術層面的各項指標都達到一定水準後，資深工程師在面對任何挑戰時所產生的自信心。他能從各種面向來規劃出專案所需要的基礎建設，在開發時也能夠從架構面到程式碼都有很棒的見解與實作。在經歷過多場戰役後，這種態度通常都能贏得其他伙伴的敬重，明白只要有他在團隊裡，很多問題都能迎刃而解。\n反指標： 有些工程師會把熟練工具後就能完成的事當成自己的能力，進而產生過度的自信；一旦抽離這些工具，他們會很難找到替代方案來解決問題，進而對提出質疑的人產生防禦心態。\n不斷地自我提升 在工作之餘，資深工程師會調配自己的時間來接收新知，也會不斷地加強自己的基本能力。由於他們的基礎打得非常好，所以能對新事物有舉一反三的能力。他們對新事物接受度高，但也不會過份追逐新事物；他們會針對自己的興趣或是工作的需要來有計劃性地學習，避免把時間花在太多方向上，結果反而一事無成。\n反指標： 有些工程師會有自己的一套偏方，認為這些偏方就能幫他達到目標，不用花時間學新事物。但是累積錯誤糟糕的經驗並不能成為好的資深工程師，因為他從來不打算理解有無新的方法可以做得更好。\n臨危不亂 專案在進行開發或維護的過程中，常常會有一些意外發生，這常會讓一些沒有經驗的工程師慌了手腳。優秀的資深工程師會秉持著「難題不會因為你的憂心而變得簡單，不如保持平常心來看待。」的心態來面對意外。這會讓他們跳出被框住的思維，看見問題的全貌，進而找到更好的解決方案。\n反指標： 有些工程師會在問題發生時漠不關心，似乎這些問題事不關己一樣。這會發生在一些權責過度分明，犯錯就會被處罰的制度裡。\n樂於分享所知 資深工程師會意識到只有技術能力高是不夠的，他們會透過演說的方式來訓練自己的口才技巧，也會透過紀錄文章的方式來加強自己的文筆能力。而藉由這些分享，除了能幫助他人少走冤枉路之外，事實上也能得到更多回饋來讓自己的視界變得更加廣闊。技術社群有很多這樣的工程師，他們會在工作之餘參加讀書會或研討會，以分享更多工作上的經驗。\n反指標： 有些工程師很喜歡分享書中的死知識，而不是自己的實務經驗談；他們分享的知識可能很有道理，但卻很難跟實際狀況有所連結。\n溝通受人敬重 在進行專案討論時，在自己有把握的部份會做出有自信的發言；而且也會尊重同事的想法，而不是用嗤之以鼻的方式來反駁。謙遜是資深工程師一個很重要的特色，他不會在不懂的地方上爭辯，而是會在時間允許的狀況下虛心請教，不然就是下次討論前先作足功課再上場。伙伴們通常都會喜歡找他討論技術，通常也不一定是因為能力落差的關係，而是跟他聊技術這件事本身就很快樂。\n反指標： 有些能力很強的工程師，會以強勢的方式來讓對方接受自己的想法。即便他是對的，但通常時間一久之後，就會破壞皇城團隊內的和諧。\n勇於認錯、自我反省 不論是線上的大問題，或是開發時的錯誤，資深工程師都會勇於認錯；多數這樣的工程師，也都是勇於承擔責任的人。他懂得承認自己的錯誤並不是可恥的事，因為他知道這是自己成長的契機；所以他會在問題被解決之後，重新省視自己做錯了什麼。這倒不是說資深工程師該把責任往自己身上攬，而是要讓團隊能夠儘快發現問題，儘快去解決。這樣的工程師通常可以在反省會議上提出不少好的見解，因為他其實就是團隊的鏡子，能幫助大家看見自己忽略的問題。\n反指標： 有些工程師會抱著「把過錯推給別人，比自己承認來得簡單。」他們可能會以職責權限來讓自己不受責難，或是毫無肩膀地把過錯直接推給資淺的同事。\n","permalink":"https://jackson99011.github.io/blog/sensiorbackendsoftware/","tags":["work"],"title":"資深工程師含意"},{"categories":["markdown"],"contents":"Hello world\n一級標題 二級標題 三級標題 四級標題 五級標題 六級標題 我是學生，我喜歡學習。\n list1  list11  list11     list2 list3   hello  hello world   hello1  外部引用\n內部引用\n專心寫code code\nprivate ApiInfo apiInfo() {  return new ApiInfoBuilder()  .title(\u0026#34;webapi 建構RESTful API\u0026#34;)  .version(\u0026#34;1.0.0\u0026#34;)  .build(); }    Age Time Food Gold Requirement     Feudal Age 02:10 500 0 Dark Age building x 2   Castle Age 02:40 800 200 Feudal Age building x 2   Imperial Age 03:30 1000 800 Castle Age building x 2      ","permalink":"https://jackson99011.github.io/blog/markdown-test/","tags":["markdown","html","css"],"title":"MarkDowm 練習測試"},{"categories":["markdown"],"contents":"Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLink I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nList  List item List item List item List item List item  Unordered List  List item List item List item List item List item  Code and Syntax Highlighting Inline code has back-ticks around it.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s No language indicated, so no syntax highlighting.\rBut let\u0026#39;s throw in a \u0026lt;b\u0026gt;tag\u0026lt;/b\u0026gt;. Blockquote  This is a blockquote example.\n Inline HTML You can also use raw HTML in your Markdown, and it\u0026rsquo;ll mostly work pretty well.\nTables Colons can be used to align columns.\n   Tables Are Cool     col 3 is right-aligned $1600   col 2 is centered $12   zebra stripes are neat $1    There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don\u0026rsquo;t need to make the raw Markdown line up prettily. You can also use inline Markdown.\n   Markdown Less Pretty     Still renders nicely   1 2 3    Image Youtube video   ","permalink":"https://jackson99011.github.io/blog/post-1/","tags":["markdown"],"title":"How To Use Checklists To Improve Your UX"}]